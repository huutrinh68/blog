(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{557:function(n,t,c){"use strict";c.r(t);var h=c(8),a=Object(h.a)({},(function(){var n=this,t=n.$createElement,c=n._self._c||t;return c("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[c("h2",{attrs:{id:"cau-hoi"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cau-hoi"}},[n._v("#")]),n._v(" Câu hỏi")]),n._v(" "),c("p",[n._v("Tại sao lại dùng convolution network trong computer vision?")]),n._v(" "),c("p",[n._v("Để trả lời thì có mấy lý do sau.")]),n._v(" "),c("h2",{attrs:{id:"_1-parameter-sharing"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#_1-parameter-sharing"}},[n._v("#")]),n._v(" 1. Parameter sharing")]),n._v(" "),c("p",[c("img",{attrs:{src:"https://user-images.githubusercontent.com/8240899/134871770-b2ddc5f7-65dd-4f6b-9ffd-0f58c8df6ebf.png",alt:"why_convolution_1"}})]),n._v(" "),c("p",[n._v("Giả sử một layer có "),c("code",[n._v("32*32*3 = 3072")]),n._v(" node. Sang layer tiếp theo có "),c("code",[n._v("28*28*6 = 4704")]),n._v(" node.\nKhi đó nếu nối tất cả các node lại với nhau thì số lượng parameter sẽ là: "),c("code",[n._v("3072*4704 ~ 14M")]),n._v(" parameters.\nSố lượng parameter giữa 2 lớp thôi đã lên đến con số hàng chục triệu.\nNếu ta tăng số kích thước ảnh đầu vào lên cao hơn nữa, giả sử là "),c("code",[n._v("1000*1000*3")]),n._v(" thì sẽ rất không khả thi trong tính toán.")]),n._v(" "),c("p",[n._v("Người ta đưa vào khái niệm parameter sharing, tức là dùng một loại filter của phần này cho cả phần khác nữa.\nTrong convolutional network, khối filter "),c("code",[n._v("3*3")]),n._v(" chẳng hạn, sẽ được quét toàn bộ ảnh, tức là dùng chung cho toàn trong một bức ảnh. Đấy chính là parameter sharing.\nCác parameter này, hay nói cách khác là các filter này chính là các feature detector, dễ hiểu hơn thì feature detector có thể dùng chung cho nhau giữa các phần khác nhau được.\nBằng cách này lượng parameter kết nối giữa các layer sẽ ít đi, và tính toán sẽ khả thi hơn cho các mạng sâu hơn.")]),n._v(" "),c("p",[n._v("Thêm vào đó, việc làm giảm số parameter đi còn có ý nghĩa là làm giảm overfiting của model đi.\n"),c("img",{attrs:{src:"https://user-images.githubusercontent.com/8240899/134871870-652e26ab-e3a7-46f3-bd0d-b037f8273bf4.png",alt:"why_convolution_2"}})]),n._v(" "),c("h2",{attrs:{id:"_2-sparsity-of-connections"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#_2-sparsity-of-connections"}},[n._v("#")]),n._v(" 2. Sparsity of connections")]),n._v(" "),c("p",[n._v("Đươc định nghĩa là ở mỗi phần của output, chỉ phụ thuộc vào một phần nào đó của input, chứ không phụ thuộc vào cả bức ảnh input.\nFilter sẽ có tác dụng lớn trong việc này, thay vì kết nối tất cả các node của 2 lớp lại với nhau,\nta chỉ dùng filter chung để kết nối các phần tử ở trong phạm vi mà filter đó quét.")]),n._v(" "),c("h2",{attrs:{id:"_3-robust-voi-translation-invariance"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#_3-robust-voi-translation-invariance"}},[n._v("#")]),n._v(" 3. Robust với translation invariance")]),n._v(" "),c("p",[n._v("Nói ngắn gọn thì đây là tính bất biến đối với sự dịch chuyển.")]),n._v(" "),c("p",[n._v("Khi ta dịch chuyển bức ảnh con mèo sang trái hay phải một chút thì con mèo vẫn cứ phải là con mèo.\nVà convolutions network thì làm rất tốt việc này, dù ta có dịch chuyển hay quay bức ảnh con mèo đi một chút thì nó vẫn nhận ra được đó là ảnh con mèo.\nViệc convolution network tự động làm được việc này chính là nhờ việc ta đã áp dụng cùng một filter vào tất cả các vị trí của bức ảnh.")]),n._v(" "),c("p",[n._v("Vì 3 lý do trên mà convolution network tỏ ra rất hiệu quả trong lĩnh vực computer vision.")])])}),[],!1,null,null,null);t.default=a.exports}}]);